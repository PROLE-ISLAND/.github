# =====================================================
# Reusable PR Governance
# PRÂìÅË≥™„ÉÅ„Çß„ÉÉ„ÇØ„ÉªËá™Âãï„É©„Éô„É™„É≥„Ç∞„ÉªÂ§âÊõ¥„Çµ„Éû„É™„Éº
# =====================================================

name: Reusable PR Governance

on:
  workflow_call:
    inputs:
      language:
        description: 'Primary language for messages (ja/en)'
        required: false
        default: 'ja'
        type: string
      require_why_section:
        description: 'Require Why section in PR description'
        required: false
        default: true
        type: boolean
      require_issue_branch:
        description: 'Require issue number in branch name for feature/bugfix/hotfix'
        required: false
        default: true
        type: boolean
      enable_auto_labeler:
        description: 'Enable automatic labeling based on changed files'
        required: false
        default: true
        type: boolean
      enable_change_summary:
        description: 'Enable change summary comment'
        required: false
        default: true
        type: boolean
      enable_variant_check:
        description: 'Enable UI component variant check'
        required: false
        default: true
        type: boolean
      size_thresholds:
        description: 'Size thresholds JSON: {"small": 100, "large": 500}'
        required: false
        default: '{"small": 100, "large": 500}'
        type: string

jobs:
  pr-quality-gate:
    name: PR Quality Gate
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v6

    - name: Check PR Description Quality
      uses: actions/github-script@v8
      with:
        script: |
          const prBody = context.payload.pull_request.body || '';
          const prTitle = context.payload.pull_request.title || '';
          const branchName = context.payload.pull_request.head.ref;
          const issues = [];
          const warnings = [];
          const lang = '${{ inputs.language }}';
          const requireWhy = ${{ inputs.require_why_section }};
          const requireIssueBranch = ${{ inputs.require_issue_branch }};

          // === Messages ===
          const msg = lang === 'ja' ? {
            branchNoIssue: (branch) => `‚ùå **„Éñ„É©„É≥„ÉÅÂêç„Å´IssueÁï™Âè∑„Åå„ÅÇ„Çä„Åæ„Åõ„Çì**: \`${branch}\`\n\nÂøÖÈ†àÂΩ¢Âºè: \`feature/issue-{Áï™Âè∑}-{Ë™¨Êòé}\``,
            branchInvalid: (branch) => `‚ùå **„Éñ„É©„É≥„ÉÅÂêç„ÅåË¶èÁ¥ÑÂ§ñ„Åß„Åô**: \`${branch}\`\n\nË®±ÂèØ„Åï„Çå„Çã„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ:\n- \`feature/issue-{Áï™Âè∑}-\`\n- \`bugfix/issue-{Áï™Âè∑}-\`\n- \`hotfix/issue-{Áï™Âè∑}-\`\n- \`chore/\`, \`docs/\`, \`ci/\`, \`deps/\``,
            missingWhy: '‚ùå **Â§âÊõ¥ÁêÜÁî±ÔºàWhyÔºâ„ÅåÊú™Ë®òÂÖ•„Åß„Åô**\n\n‰Ωï„ÇíÊõ∏„Åë„Å∞„ÅÑ„ÅÑ„Åã:\n- „É¶„Éº„Ç∂„Éº‰æ°ÂÄ§\n- ÊäÄË°ìÁöÑËÉåÊôØ\n- ‰ª£ÊõøÊ°à„ÅÆÊ§úË®é',
            missingWhat: '‚ö†Ô∏è **ÁõÆÁöÑÔºàWhatÔºâ„ÅåÊú™Ë®òÂÖ•„Åß„Åô**',
            missingRisk: '‚ö†Ô∏è **„É™„Çπ„ÇØË©ï‰æ°„ÉÜ„Éº„Éñ„É´„ÅåÊú™Ë®òÂÖ•„Åß„Åô**',
            noIssueRef: '‚ö†Ô∏è **Èñ¢ÈÄ£Issue„ÅÆË®òËºâ„Åå„ÅÇ„Çä„Åæ„Åõ„Çì**',
            checkHeader: '## üõ°Ô∏è PR Governance Check\n\n',
            errorHeader: '### ‚ùå ÂøÖÈ†àÈ†ÖÁõÆ„ÅÆ‰∏çÂÇô\n\n',
            errorNote: '> **„Åì„ÅÆPR„ÅØ„É¨„Éì„É•„ÉºÂØæË±°Â§ñ„Åß„Åô„ÄÇ‰∏äË®ò„Çí‰øÆÊ≠£„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ**\n\n',
            warningHeader: '### ‚ö†Ô∏è Êé®Â•®‰∫ãÈ†Ö\n\n',
            passAll: '### ‚úÖ All checks passed!\n\nPR description„ÅåÈÅ©Âàá„Å´Ë®òËºâ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ',
            passRequired: '### ‚úÖ ÂøÖÈ†àÈ†ÖÁõÆOK\n\n„É¨„Éì„É•„ÉºÂèØËÉΩ„Åß„Åô„Åå„ÄÅ‰∏äË®ò„ÅÆÊé®Â•®‰∫ãÈ†Ö„ÅÆÂØæÂøú„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'
          } : {
            branchNoIssue: (branch) => `‚ùå **Branch name missing issue number**: \`${branch}\`\n\nRequired format: \`feature/issue-{number}-{description}\``,
            branchInvalid: (branch) => `‚ùå **Invalid branch name**: \`${branch}\`\n\nAllowed prefixes:\n- \`feature/issue-{number}-\`\n- \`bugfix/issue-{number}-\`\n- \`hotfix/issue-{number}-\`\n- \`chore/\`, \`docs/\`, \`ci/\`, \`deps/\``,
            missingWhy: '‚ùå **Missing Why section**\n\nInclude:\n- User value\n- Technical background\n- Alternatives considered',
            missingWhat: '‚ö†Ô∏è **Missing What section**',
            missingRisk: '‚ö†Ô∏è **Missing risk assessment table**',
            noIssueRef: '‚ö†Ô∏è **No related issue referenced**',
            checkHeader: '## üõ°Ô∏è PR Governance Check\n\n',
            errorHeader: '### ‚ùå Required Items Missing\n\n',
            errorNote: '> **This PR is not ready for review. Please fix the issues above.**\n\n',
            warningHeader: '### ‚ö†Ô∏è Recommendations\n\n',
            passAll: '### ‚úÖ All checks passed!\n\nPR description is properly filled.',
            passRequired: '### ‚úÖ Required items OK\n\nReady for review, but consider addressing the warnings above.'
          };

          // === Branch name check ===
          if (requireIssueBranch) {
            const issueRequiredPatterns = [
              /^feature\/issue-\d+-/,
              /^bugfix\/issue-\d+-/,
              /^hotfix\/issue-\d+-/,
            ];
            const maintenancePatterns = [
              /^chore\//, /^fix\//, /^docs\//, /^ci\//, /^deps\//, /^dependabot\//, /^renovate\//,
            ];

            const hasIssueNumber = issueRequiredPatterns.some(p => p.test(branchName));
            const isMaintenance = maintenancePatterns.some(p => p.test(branchName));

            if (!hasIssueNumber && !isMaintenance) {
              if (branchName.startsWith('feature/') || branchName.startsWith('bugfix/') || branchName.startsWith('hotfix/')) {
                issues.push(msg.branchNoIssue(branchName));
              } else {
                issues.push(msg.branchInvalid(branchName));
              }
            }
          }

          // === Why section check ===
          if (requireWhy) {
            const whySection = prBody.match(/## 2\.?\s*Â§âÊõ¥ÁêÜÁî±ÔºàWhyÔºâ[^\n]*\n+([\s\S]*?)(?=\n## |\n---|\Z)/);
            const whyContent = whySection ? whySection[1].trim() : '';
            const whyClean = whyContent.replace(/<!--[\s\S]*?-->/g, '').trim();

            if (!whyClean || whyClean.length < 10) {
              issues.push(msg.missingWhy);
            }
          }

          // === What section check ===
          const whatSection = prBody.match(/## 1\.?\s*ÁõÆÁöÑÔºàWhatÔºâ[^\n]*\n+([\s\S]*?)(?=\n## |\Z)/);
          const whatContent = whatSection ? whatSection[1].replace(/<!--[\s\S]*?-->/g, '').trim() : '';
          if (!whatContent || whatContent.length < 5) {
            warnings.push(msg.missingWhat);
          }

          // === Risk assessment check ===
          const riskFilled = prBody.match(/\|\s*(Low|Med|High)\s*\|/i);
          if (!riskFilled) {
            warnings.push(msg.missingRisk);
          }

          // === Issue reference check ===
          const hasIssueRef = prBody.match(/#\d+/) || prBody.match(/Closes|Fixes|Relates/i);
          if (!hasIssueRef) {
            warnings.push(msg.noIssueRef);
          }

          // === Generate comment ===
          let comment = msg.checkHeader;

          if (issues.length > 0) {
            comment += msg.errorHeader + issues.join('\n\n') + '\n\n' + msg.errorNote;
          }
          if (warnings.length > 0) {
            comment += msg.warningHeader + warnings.join('\n') + '\n\n';
          }
          if (issues.length === 0 && warnings.length === 0) {
            comment += msg.passAll;
          } else if (issues.length === 0) {
            comment += msg.passRequired;
          }

          // === Post/Update comment ===
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });

          const botComment = comments.find(c =>
            c.user.type === 'Bot' && c.body.includes('PR Governance Check')
          );

          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: comment
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
          }

          if (issues.length > 0) {
            core.setFailed('PR description is incomplete.');
          }

  auto-labeler:
    name: Auto Label
    runs-on: ubuntu-latest
    if: ${{ inputs.enable_auto_labeler }}

    steps:
    - name: Checkout
      uses: actions/checkout@v6
      with:
        fetch-depth: 0

    - name: Add Labels Based on Files
      uses: actions/github-script@v8
      with:
        script: |
          const { data: files } = await github.rest.pulls.listFiles({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.issue.number,
          });

          const labels = new Set();
          const thresholds = JSON.parse('${{ inputs.size_thresholds }}');

          for (const file of files) {
            const path = file.filename;

            if (path.startsWith('src/components/') || path.includes('.tsx') || path.includes('.jsx')) {
              labels.add('frontend');
            }
            if (path.startsWith('src/app/api/') || path.startsWith('api/')) {
              labels.add('backend');
            }
            if (path.includes('supabase') || path.includes('migration') || path.includes('schema')) {
              labels.add('database');
            }
            if (path.startsWith('.github/') || path.includes('docker') || path.includes('vercel')) {
              labels.add('infrastructure');
            }
            if (path.endsWith('.md') || path.startsWith('docs/')) {
              labels.add('documentation');
            }
            if (path.includes('test') || path.includes('spec') || path.startsWith('e2e/')) {
              labels.add('tests');
            }
          }

          // Size labels
          const totalChanges = files.reduce((sum, f) => sum + f.changes, 0);
          if (totalChanges > thresholds.large) {
            labels.add('size/large');
          } else if (totalChanges > thresholds.small) {
            labels.add('size/medium');
          } else {
            labels.add('size/small');
          }

          if (labels.size > 0) {
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: Array.from(labels)
            });
          }

  file-change-summary:
    name: Change Summary
    runs-on: ubuntu-latest
    if: ${{ inputs.enable_change_summary }}

    steps:
    - name: Checkout
      uses: actions/checkout@v6
      with:
        fetch-depth: 0

    - name: Generate Change Summary
      uses: actions/github-script@v8
      with:
        script: |
          const { data: files } = await github.rest.pulls.listFiles({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.issue.number,
          });

          const lang = '${{ inputs.language }}';

          // Directory change aggregation
          const dirChanges = {};
          let totalAdditions = 0;
          let totalDeletions = 0;

          for (const file of files) {
            const dir = file.filename.split('/').slice(0, 2).join('/') || file.filename;
            if (!dirChanges[dir]) {
              dirChanges[dir] = { files: 0, additions: 0, deletions: 0 };
            }
            dirChanges[dir].files++;
            dirChanges[dir].additions += file.additions;
            dirChanges[dir].deletions += file.deletions;
            totalAdditions += file.additions;
            totalDeletions += file.deletions;
          }

          // Generate summary
          const header = lang === 'ja' ? '## üìä Â§âÊõ¥„Çµ„Éû„É™„Éº' : '## üìä Change Summary';
          const totalLabel = lang === 'ja' ? 'ÂêàË®à' : 'Total';
          const dirLabel = lang === 'ja' ? '„Éá„Ç£„É¨„ÇØ„Éà„É™' : 'Directory';
          const filesLabel = lang === 'ja' ? '„Éï„Ç°„Ç§„É´Êï∞' : 'Files';

          let summary = `${header}\n\n`;
          summary += `**${totalLabel}**: ${files.length} files (+${totalAdditions} -${totalDeletions})\n\n`;
          summary += `| ${dirLabel} | ${filesLabel} | + | - |\n`;
          summary += '|-------------|-----------|------|------|\n';

          for (const [dir, stats] of Object.entries(dirChanges).sort((a, b) => b[1].files - a[1].files)) {
            summary += `| \`${dir}\` | ${stats.files} | +${stats.additions} | -${stats.deletions} |\n`;
          }

          // Post/Update comment
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });

          const existingSummary = comments.find(c =>
            c.user.type === 'Bot' && (c.body.includes('Â§âÊõ¥„Çµ„Éû„É™„Éº') || c.body.includes('Change Summary'))
          );

          if (existingSummary) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: existingSummary.id,
              body: summary
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: summary
            });
          }

  variant-check:
    name: Variant Check
    runs-on: ubuntu-latest
    if: ${{ inputs.enable_variant_check }}

    steps:
    - name: Checkout
      uses: actions/checkout@v6
      with:
        fetch-depth: 0

    - name: Check UI Component Variants
      uses: actions/github-script@v8
      with:
        script: |
          const { data: files } = await github.rest.pulls.listFiles({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.issue.number,
          });

          const fs = require('fs');
          const path = require('path');
          const lang = '${{ inputs.language }}';

          // Target: New .tsx files in src/components/ (excluding ui/)
          const newComponentFiles = files.filter(f =>
            f.status === 'added' &&
            f.filename.endsWith('.tsx') &&
            f.filename.startsWith('src/components/') &&
            !f.filename.startsWith('src/components/ui/')
          );

          if (newComponentFiles.length === 0) {
            console.log('No new UI components detected.');
            return;
          }

          const issues = [];
          const warnings = [];

          for (const file of newComponentFiles) {
            try {
              const content = fs.readFileSync(file.filename, 'utf8');
              const componentName = path.basename(file.filename, '.tsx');

              const testIdPattern = /data-testid=["'`]([^"'`]+)["'`]/g;
              const foundTestIds = [];
              let match;
              while ((match = testIdPattern.exec(content)) !== null) {
                foundTestIds.push(match[1]);
              }

              const kebabName = componentName
                .replace(/([a-z])([A-Z])/g, '$1-$2')
                .toLowerCase();

              const requiredVariants = [
                { suffix: '', name: 'Default' },
                { suffix: '-skeleton', name: 'Loading' },
                { suffix: '-empty', name: 'Empty' },
                { suffix: '-error', name: 'Error' }
              ];

              const missingVariants = [];
              for (const variant of requiredVariants) {
                const expectedTestId = kebabName + variant.suffix;
                const hasVariant = foundTestIds.some(id =>
                  id === expectedTestId || id.includes(expectedTestId)
                );
                if (!hasVariant) {
                  missingVariants.push(`\`${expectedTestId}\` (${variant.name})`);
                }
              }

              if (missingVariants.length > 0) {
                if (missingVariants.length === 4) {
                  const msg = lang === 'ja'
                    ? `‚ö†Ô∏è **${file.filename}**\n   data-testid„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ`
                    : `‚ö†Ô∏è **${file.filename}**\n   No data-testid found.`;
                  warnings.push(msg);
                } else {
                  const msg = lang === 'ja'
                    ? `‚ùå **${file.filename}**\n   ‰∏çË∂≥„Éê„É™„Ç¢„É≥„Éà: ${missingVariants.join(', ')}`
                    : `‚ùå **${file.filename}**\n   Missing variants: ${missingVariants.join(', ')}`;
                  issues.push(msg);
                }
              }
            } catch (e) {
              console.log(`Could not read file: ${file.filename}`);
            }
          }

          if (issues.length === 0 && warnings.length === 0) {
            console.log('All components have proper variants.');
            return;
          }

          const header = lang === 'ja' ? '## üé® Variant Check' : '## üé® Variant Check';
          let comment = header + '\n\n';

          if (issues.length > 0) {
            const errorHeader = lang === 'ja' ? '### ‚ùå „Éê„É™„Ç¢„É≥„Éà‰∏çË∂≥' : '### ‚ùå Missing Variants';
            comment += errorHeader + '\n\n' + issues.join('\n') + '\n\n';
          }
          if (warnings.length > 0) {
            const warnHeader = lang === 'ja' ? '### ‚ö†Ô∏è Á¢∫Ë™ç„ÅåÂøÖË¶Å' : '### ‚ö†Ô∏è Review Needed';
            comment += warnHeader + '\n\n' + warnings.join('\n') + '\n\n';
          }

          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          });

          const existingComment = comments.find(c =>
            c.user.type === 'Bot' && c.body.includes('Variant Check')
          );

          if (existingComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: existingComment.id,
              body: comment
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
          }

          if (issues.length > 0) {
            core.setFailed('Missing variant data-testids.');
          }
