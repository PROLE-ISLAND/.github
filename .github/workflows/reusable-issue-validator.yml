# =====================================================
# Reusable Issue Template Validator
# çµ„ç¹”å…¨ä½“ã§ä½¿ç”¨å¯èƒ½ãªå†åˆ©ç”¨å¯èƒ½ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
# =====================================================

name: Reusable Issue Validator

on:
  workflow_call:
    inputs:
      language:
        description: 'Primary language for messages (ja/en)'
        required: false
        default: 'ja'
        type: string
      require_figma:
        description: 'Require Figma link for UI features'
        required: false
        default: true
        type: boolean
      require_variant_checklist:
        description: 'Require component variant checklist'
        required: false
        default: true
        type: boolean
      feature_labels:
        description: 'Labels to add for feature requests (comma-separated)'
        required: false
        default: 'feature,needs-triage,design-review'
        type: string
      bug_labels:
        description: 'Labels to add for bug reports (comma-separated)'
        required: false
        default: 'bug,needs-triage'
        type: string

jobs:
  validate-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Validate Issue Format
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const title = issue.title || '';
            const labels = issue.labels.map(l => l.name);
            const lang = '${{ inputs.language }}';
            const requireFigma = ${{ inputs.require_figma }};
            const requireVariants = ${{ inputs.require_variant_checklist }};

            // Skip if already has validation label
            if (labels.includes('template-valid') || labels.includes('template-bypass')) {
              console.log('Issue already validated or bypassed');
              return;
            }

            const errors = [];
            const warnings = [];
            let issueType = null;
            let requiredLabels = [];

            // =====================================================
            // Determine issue type from title prefix (æ—¥æœ¬èªž/è‹±èªžå¯¾å¿œ)
            // =====================================================
            if (title.startsWith('[æ©Ÿèƒ½]:') || title.startsWith('[æ©Ÿèƒ½]') ||
                title.startsWith('[Feature]:') || title.startsWith('[Feature]')) {
              issueType = 'feature';
              requiredLabels = '${{ inputs.feature_labels }}'.split(',').map(s => s.trim());
            } else if (title.startsWith('[ãƒã‚°]:') || title.startsWith('[ãƒã‚°]') ||
                       title.startsWith('[Bug]:') || title.startsWith('[Bug]')) {
              issueType = 'bug';
              requiredLabels = '${{ inputs.bug_labels }}'.split(',').map(s => s.trim());
            }

            // =====================================================
            // Messages (æ—¥æœ¬èªž/è‹±èªž)
            // =====================================================
            const msg = lang === 'ja' ? {
              missingSection: (name) => `âŒ å¿…é ˆã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã›ã‚“: **${name}**`,
              missingPreCheck: 'âŒ äº‹å‰ç¢ºèªãŒãƒã‚§ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã›ã‚“: **é‡è¤‡IssueãŒãªã„ã“ã¨ã‚’ç¢ºèªã—ã¾ã—ãŸ**',
              missingFigma: 'âš ï¸ **Figmaãƒªãƒ³ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“**: UIæ©Ÿèƒ½ã«ã¯Figmaãƒ¢ãƒƒã‚¯ã‚¢ãƒƒãƒ—ãŒå¿…è¦ã§ã™ã€‚ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ã¿ã®å ´åˆã¯ã€Œãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ã¿ã®æ©Ÿèƒ½ã€ã«ãƒã‚§ãƒƒã‚¯ã‚’å…¥ã‚Œã¦ãã ã•ã„ã€‚',
              missingVariants: 'âš ï¸ **ãƒãƒªã‚¢ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆãŒã‚ã‚Šã¾ã›ã‚“**: UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«ã¯Default/Loading/Empty/Errorãƒãƒªã‚¢ãƒ³ãƒˆãŒå¿…è¦ã§ã™ã€‚',
              missingFiveLenses: 'âš ï¸ **5ã¤ã®ãƒ¬ãƒ³ã‚ºè©•ä¾¡ãŒä¸å®Œå…¨**: Gold E2Eå€™è£œã®å ´åˆã¯5ã¤ã®ãƒ¬ãƒ³ã‚ºè©•ä¾¡ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è¨˜å…¥ã—ã¦ãã ã•ã„ã€‚',
              missingScope: 'âš ï¸ **å½±éŸ¿ç¯„å›²ãŒæœªé¸æŠž**: ãƒ•ãƒ­ãƒ³ãƒˆ/ãƒãƒƒã‚¯/DB/ã‚¤ãƒ³ãƒ•ãƒ©ã®å½±éŸ¿ç¯„å›²ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚',
              noTemplate: 'âŒ **IssueãŒãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå½¢å¼ã«å¾“ã£ã¦ã„ã¾ã›ã‚“ã€‚** Issueä½œæˆæ™‚ã¯ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„:',
              wrongPrefix: 'âŒ **ã‚¿ã‚¤ãƒˆãƒ«å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚** `[æ©Ÿèƒ½]: ...` ã¾ãŸã¯ `[ãƒã‚°]: ...` ãƒ—ãƒ¬ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚',
              commentHeader: '## ðŸ“‹ Issueãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆæ¤œè¨¼\n\n',
              errorHeader: '### ã‚¨ãƒ©ãƒ¼ï¼ˆä¿®æ­£å¿…é ˆï¼‰\n\n',
              errorNote: '> **æ³¨æ„**: ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«å¾“ã£ã¦ã„ãªã„Issueã¯ã€ã‚¯ãƒ­ãƒ¼ã‚ºã¾ãŸã¯ç·¨é›†ãŒå¿…è¦ã«ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚\n\n',
              warningHeader: '### è­¦å‘Š\n\n',
              footer: '---\n*ã“ã‚Œã¯è‡ªå‹•ãƒã‚§ãƒƒã‚¯ã§ã™ã€‚æ„å›³çš„ã«ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹å ´åˆã¯ `template-bypass` ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚*'
            } : {
              missingSection: (name) => `âŒ Missing required section: **${name}**`,
              missingPreCheck: 'âŒ Pre-check not confirmed: **Confirmed no duplicate issues**',
              missingFigma: 'âš ï¸ **Missing Figma link**: UI features require Figma mockups. Check "Backend-only feature" if no UI.',
              missingVariants: 'âš ï¸ **Missing variant checklist**: UI components need Default/Loading/Empty/Error variants.',
              missingFiveLenses: 'âš ï¸ **Incomplete 5 Lenses evaluation**: Gold E2E candidates require the 5 Lenses table.',
              missingScope: 'âš ï¸ **Scope not selected**: Check affected areas (Frontend/Backend/DB/Infrastructure).',
              noTemplate: 'âŒ **Issue does not follow template format.** Please use a template:',
              wrongPrefix: 'âŒ **Invalid title format.** Use `[Feature]: ...` or `[Bug]: ...` prefix.',
              commentHeader: '## ðŸ“‹ Issue Template Validation\n\n',
              errorHeader: '### Errors (Must Fix)\n\n',
              errorNote: '> **Note**: Issues not following templates may be closed or require editing.\n\n',
              warningHeader: '### Warnings\n\n',
              footer: '---\n*This is an automated check. Add `template-bypass` label to skip validation.*'
            };

            // =====================================================
            // Validate Feature Request
            // =====================================================
            if (issueType === 'feature') {
              const requiredSections = [
                { name: lang === 'ja' ? 'å„ªå…ˆåº¦' : 'Priority', pattern: /### (å„ªå…ˆåº¦|Priority)\s*\n[^\n]+/i },
                { name: lang === 'ja' ? 'å“è³ªãƒ¬ãƒ™ãƒ«' : 'DoD Level', pattern: /### (å“è³ªãƒ¬ãƒ™ãƒ«ï¼ˆDoDï¼‰|DoD Level)\s*\n[^\n]+/i },
                { name: lang === 'ja' ? 'æ©Ÿèƒ½èª¬æ˜Ž' : 'Description', pattern: /### (æ©Ÿèƒ½èª¬æ˜Ž|Feature Description)\s*\n/i },
                { name: lang === 'ja' ? 'èƒŒæ™¯ãƒ»å‹•æ©Ÿ' : 'Background', pattern: /### (èƒŒæ™¯ãƒ»å‹•æ©Ÿï¼ˆWhyï¼‰|Background)\s*\n/i },
                { name: lang === 'ja' ? 'ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹å®šç¾©' : 'Use Case', pattern: /### (ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹å®šç¾©ï¼ˆRole Ã— Outcomeï¼‰|Usecase)\s*\n/i },
                { name: lang === 'ja' ? 'å—ã‘å…¥ã‚Œæ¡ä»¶' : 'Acceptance Criteria', pattern: /### (å—ã‘å…¥ã‚Œæ¡ä»¶|Acceptance Criteria)\s*\n/i },
                { name: lang === 'ja' ? 'ãƒ†ã‚¹ãƒˆè¨ˆç”»' : 'Test Plan', pattern: /### (ãƒ†ã‚¹ãƒˆè¨ˆç”»|Test Plan)\s*\n/i },
              ];

              for (const section of requiredSections) {
                if (!section.pattern.test(body)) {
                  errors.push(msg.missingSection(section.name));
                }
              }

              // Pre-check confirmation
              const hasPreCheck = /é‡è¤‡IssueãŒãªã„ã“ã¨ã‚’ç¢ºèªã—ã¾ã—ãŸ|Confirmed no duplicate/.test(body) &&
                                  /\[x\]/i.test(body.match(/(é‡è¤‡IssueãŒãªã„ã“ã¨ã‚’ç¢ºèª|Confirmed no duplicate)[^\n]*/)?.[0] || '');
              if (!hasPreCheck) {
                errors.push(msg.missingPreCheck);
              }

              // Figma link check
              if (requireFigma) {
                const figmaMatch = body.match(/### (Figmaãƒ¢ãƒƒã‚¯ã‚¢ãƒƒãƒ—|Figma)\s*\n([^\n]+)/i);
                const hasBackendOnly = /(ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ã¿ã®æ©Ÿèƒ½|backend-only feature)/i.test(body) &&
                                       /\[x\]/i.test(body.match(/(ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ã¿|backend-only)[^\n]*/i)?.[0] || '');
                if (!hasBackendOnly && (!figmaMatch || !figmaMatch[2].includes('figma.com'))) {
                  warnings.push(msg.missingFigma);
                }
              }

              // Variant checklist
              if (requireVariants) {
                const hasBackendOnly = /(ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®ã¿ã®æ©Ÿèƒ½|backend-only feature)/i.test(body);
                const hasVariants = /### (ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒãƒªã‚¢ãƒ³ãƒˆ|Component Variant)/i.test(body);
                if (!hasBackendOnly && !hasVariants) {
                  warnings.push(msg.missingVariants);
                }
              }

              // Gold E2E check
              const isGoldE2E = /### Gold E2E.*\n\s*(ã¯ã„|Yes)/i.test(body);
              const hasFiveLenses = /### (5ã¤ã®ãƒ¬ãƒ³ã‚º|5 Lenses)/i.test(body) && /\| (ãƒ¬ãƒ³ã‚º|Lens) \|/i.test(body);
              if (isGoldE2E && !hasFiveLenses) {
                warnings.push(msg.missingFiveLenses);
              }

              // Affected scope
              if (!/### (å½±éŸ¿ç¯„å›²|Affected Scope)/i.test(body)) {
                warnings.push(msg.missingScope);
              }
            }

            // =====================================================
            // Validate Bug Report
            // =====================================================
            if (issueType === 'bug') {
              const requiredSections = [
                { name: lang === 'ja' ? 'å„ªå…ˆåº¦' : 'Priority', pattern: /### (å„ªå…ˆåº¦|Priority)\s*\n[^\n]+/i },
                { name: lang === 'ja' ? 'å“è³ªãƒ¬ãƒ™ãƒ«' : 'DoD Level', pattern: /### (å“è³ªãƒ¬ãƒ™ãƒ«ï¼ˆDoDï¼‰|DoD Level)\s*\n[^\n]+/i },
                { name: lang === 'ja' ? 'ãƒã‚°ã®èª¬æ˜Ž' : 'Bug Description', pattern: /### (ãƒã‚°ã®èª¬æ˜Ž|Bug Description)\s*\n/i },
                { name: lang === 'ja' ? 'å†ç¾æ‰‹é †' : 'Steps to Reproduce', pattern: /### (å†ç¾æ‰‹é †|Steps to Reproduce)\s*\n/i },
                { name: lang === 'ja' ? 'æœŸå¾…ã•ã‚Œã‚‹å‹•ä½œ' : 'Expected Behavior', pattern: /### (æœŸå¾…ã•ã‚Œã‚‹å‹•ä½œ|Expected Behavior)\s*\n/i },
                { name: lang === 'ja' ? 'å½±éŸ¿ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«' : 'Affected Files', pattern: /### (å½±éŸ¿ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«|Affected Files)\s*\n/i },
                { name: lang === 'ja' ? 'ãƒ†ã‚¹ãƒˆè¨ˆç”»' : 'Test Plan', pattern: /### (ãƒ†ã‚¹ãƒˆè¨ˆç”»|Test Plan)\s*\n/i },
                { name: lang === 'ja' ? 'å—ã‘å…¥ã‚Œæ¡ä»¶' : 'Acceptance Criteria', pattern: /### (å—ã‘å…¥ã‚Œæ¡ä»¶|Acceptance Criteria)\s*\n/i },
              ];

              for (const section of requiredSections) {
                if (!section.pattern.test(body)) {
                  errors.push(msg.missingSection(section.name));
                }
              }
            }

            // =====================================================
            // No template used
            // =====================================================
            if (!issueType) {
              const hasTemplateStructure = /### (å„ªå…ˆåº¦|Priority|èƒŒæ™¯|Background|ãƒã‚°ã®èª¬æ˜Ž|Bug Description)/i.test(body);
              if (!hasTemplateStructure) {
                errors.push(msg.noTemplate);
                errors.push(`  - [æ©Ÿèƒ½è¦æœ›](https://github.com/${context.repo.owner}/${context.repo.repo}/issues/new?template=feature_request.yml)`);
                errors.push(`  - [ãƒã‚°å ±å‘Š](https://github.com/${context.repo.owner}/${context.repo.repo}/issues/new?template=bug_report.yml)`);
              } else {
                errors.push(msg.wrongPrefix);
              }
            }

            // =====================================================
            // Auto-add labels
            // =====================================================
            if (issueType && requiredLabels.length > 0) {
              const missingLabels = requiredLabels.filter(l => l && !labels.includes(l));
              if (missingLabels.length > 0) {
                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    labels: missingLabels
                  });
                } catch (e) {
                  console.error('Failed to add labels:', e);
                }
              }
            }

            // =====================================================
            // Post validation result
            // =====================================================
            if (errors.length > 0 || warnings.length > 0) {
              let comment = msg.commentHeader;
              if (errors.length > 0) {
                comment += msg.errorHeader + errors.join('\n') + '\n\n' + msg.errorNote;
              }
              if (warnings.length > 0) {
                comment += msg.warningHeader + warnings.join('\n') + '\n\n';
              }
              comment += msg.footer;

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: comment
              });

              if (errors.length > 0) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['needs-template-fix']
                });
              }
            } else if (issueType) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: ['template-valid']
              });
            }
